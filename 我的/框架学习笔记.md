# 事件的使用

## 对象之间的交互 和 模块化

**交互（低耦合）模块化（高内聚）**



对象之间的交互一般分为三种

```
方法调用，例如：A调用B的SayHello方法
A需要持有B才能调用B的方法

委托或者回调，例如：界面监听子按钮的点击事件
A需要持有B才能注册B的委托

消息或者事件，例如：服务器向客户端发送通知
```



父节点可以直接引用子节点的方法调用

子节点需要调用父节点的方法时，用委托或者事件

跨模块通信用事件









 **1.事件是对委托的封装** 

继承泛型类的拥有事件

```
using System;

public  class Event<T> where T:Event<T>
{

    private static Action OnEvent;

    public static void Register(Action action)
    {
        OnEvent += action;
    }

    public static void UnRegister(Action action)
    {
        OnEvent -= action;
    }

    public static void Trigger()
    {
        OnEvent?.Invoke();
    }

}
```

## Event

Button那种拖事件

```
using UnityEngine.Events;

[System.Serializable]
public class EventVector3 : UnityEvent<Vector3> { };

public class MouseManager : MonoBehaviour
{
  
    public EventVector3 OnMouseClicked;

}

```

```
 
 注册事件，这个值就是拖进来的对象Navigation的值所需
 OnMouseClicked?.Invoke(hitInfo.point);
```

## Action

```
using System;//自带的好用

public class MouseManager :SingLeton<MouseManager>
{
    public event Action<Vector3> OnMouseClicked;
```

```
通过单例去调用player上注册事件，这个事件方法指代的是NavMeshAgent的属性
```

